# AGENTS.md — Diagram-to-Java Repo Reconstruction (No-Stubs Policy)

## Mission
You are reconstructing a complete, working Java repository from a single PlantUML diagram (`.puml`) that represents an "old repo".
Your output must be a coherent, runnable project that compiles, passes tests, and can be executed through a demo entrypoint.

### Hard requirements
- Language: **Java**
- Build tool: **Gradle OR Maven** (pick exactly one and make it work)
  - Do not include both Gradle and Maven build definitions in the generated repo.
- Input source of truth: the provided `.puml` diagram only.
  - You are limited to your specific run folder. It is strictly prohibited to read or do anything outside of this folder. 
  - If behavior is underspecified by the diagram, make a reasonable implementation choice and record it.
- **No placeholder stubs**: do not create empty methods/classes just to satisfy compilation.
  - If something is unclear, make a reasonable implementation choice and **log it**.
- Ambiguity handling:
  - Never stop due to ambiguity.
  - Record decisions in `docs/ASSUMPTIONS.md` and continue.
- Tests are mandatory:
  - Include meaningful unit tests for core logic.
  - Include integration tests where the system has boundaries (HTTP, DB, filesystem), using mocks or containers as appropriate.
- Runnable demo is mandatory:
  - Include at least one production entrypoint: `public static void main(String[] args)` in `src/main/java`.
  - Include an executable repo-root script `run_demo.sh` that runs the demo entrypoint.
  - `run_demo.sh` must be deterministic and runnable on a clean local machine without IDE-specific setup.
  - `README.md` must clearly document how to run the demo (`./run_demo.sh`).

## Output artifacts required
You must create:
- `README.md` — how to build/test/run
- `docs/ASSUMPTIONS.md` — all ambiguity + decisions
- `docs/ARCHITECTURE.md` — short explanation of layers/modules and key flows
- `run_demo.sh` — executable demo launcher

## Stop condition (non-negotiable)
Do not consider the task complete until `./gate_recon.sh` passes.
If it fails, fix the issues and re-run it. Repeat until green.

## No “status update” trap
Do not produce upfront plans or progress reports.
Do the work, run the gate, fix failures, repeat. Only write a brief final summary once the gate passes.

## Build + test conventions
- Prefer one of:
  - Gradle wrapper: `./gradlew test`
  - Maven: `mvn -q test`
- If using Gradle, include an executable `./gradlew`.
- Keep the project runnable on a clean machine (no IDE-only magic).
- Pin dependency versions reasonably (use BOMs where appropriate).

## No-stubs policy (enforced)
If you truly must defer a piece of functionality (rare), mark it explicitly with:
- `TODO-STUB: <reason>`
This is considered a failure state; you must eliminate all `TODO-STUB` markers before completion.

## Code quality baseline
- Favor clear, idiomatic Java.
- Use consistent package structure.
- Prefer constructor injection if using DI frameworks.
- Include basic static checks if cheap (e.g., Spotless/Checkstyle) but do not block completion if not specified by the diagram.

## Determinism and logging
- If behavior could be nondeterministic (timestamps, random IDs), document it and control it where possible.
- Logs are allowed; tests should not depend on log text.

## Future-proofing (multi-model runner)
Assume this repo may be generated by different models/agents later.
Therefore:
- Keep setup and gates fully scriptable.
- Avoid agent-specific instructions in code or docs.
- Ensure all commands work from the repo root in a shell environment.
